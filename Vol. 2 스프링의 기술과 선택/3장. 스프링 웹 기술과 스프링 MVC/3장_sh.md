# 스프링 웹 기술과 스프링 MVC



웹 계층은 기술적으로 변화가 많은 계층이다. 스프링은 이런 상황을 대비해서 웹 계층을 다른 계층과 분리하여 개발하는 아키텍처 모델을 추구한다. 

<br/>

### [학습 목표]

- 스프링의 웹 계층 설계 기본원칙
- 스프링 웹 기술의 선정 기본원칙
- 스프링 웹 기술의 다양한 전략

<br/>

스프링에는 두 가지의 '서블릿 웹 애플리케이션 컨텍스트'가 존재한다. 

​	(1) 루트 애플리케이션 컨텍스트: 비즈니스 계층과 데이터 액세스 계층을 작성

​	(2) 서블릿 애플리케이션 컨텍스트: 스프링 웹 기술 기반으로 동작하는 웹 관련 빈 작성

> #### (!) 분리한 이유
>
> - 스프링 웹 서블릿 컨텍스트를 통쨰로 다른 기술로 대체할 수 있도록 하기 위함

<br/>

### 웹 프레임워크로 사용할 수 있는 것들

#### 스프링 웹 프레임워크

- **스프링 서블릿/스프링 MVC**
- 스프링 포틀릿

#### 스프링 포트폴리오 웹 프레임워크

- SWF (Spring Web Flow)
- Spring JavaScript
- Spring Faces
- Spring Web Service
- Spring BlazeDS Integration

#### 스프링 기반이 아닌 웹 프레임워크

- JSP/Servlet
- Struts1 
- Strust2
- Tapestry3, 4 (테피스트리)
- JSF/Seam

<br/>

스프링이 제공해준 MVC 프레임워크에 프로젝트 특성에 맞게 빠르고 편리한 개발이 가능하도록, 필요한 전략을 추가해서 사용할 줄 알아야 한다. 

### 디스패처 서블릿 : 스프링 웹 기술의 핵심/기반

> MVC : 모델 / 뷰 / 컨트롤러가 서로 협력해서 하나의 웹 요청을 처리하고 응답을 만들어내는 구조. 보통 '프론트 컨트롤러 패턴'과 함꼐 사용된다. 이 패턴은 컨트롤러를 프레젠테이션 계층의 가장 앞단에 둬서 서버로 들어오는 모든 요청을 받아서 처리하는 패턴이다. 프론트 컨트롤러의 역할은, 
>
> ​	1) 클라 요청을 받아서 공통작업 수행 후 적절한 세부 컨트롤러로 작업 위임해준다. 
>
> ​	2) 클라에게 보낼 뷰 선택해서 최종 결과 생성해준다.
>
> ​	3) 예외 발생 시 일관되게 처리해준다. 

#### 스프링 서블릿/MVC의 핵심 프론트 컨트롤러 => 디스패처 서블릿

(그림 3-1)

1) HTTP 요청이 들어오고 / 이 요청이 스프링의 디스패처서블릿에 할당된 요청인지 서블릿컨테이너가 판단해서 / 맞으면 서블릿 컨테이너가 HTTP 요청정보를 디스패처 서블릿에 전달해준다. 

- 디스패처서블릿에 할당된 요청인 지 확인은 web.xml에 작성된 '디스패처 서블릿이 전달받을 URL 패턴'을 보고 판단함
- HTTP 요청은 GET과 POST로 구분되고 쿼리스트링/폼파라미터/쿠키/헤더 같은 정보가 전달됨

<br/>

2) 디스패처서블릿이 URL이나 파라미터정보 HTTP 명령 등을 참고해서 어떤 컨트롤러(핸들러)에게 작업을 위임할 지 결정한다. 이것을 '핸들러 매핑전략'이라고 한다. 그리고 난 후 결정한 컨트롤러오브젝의 메소드를 호출해서 실제 웹 요청을 처리하는 작업을 위임한다. 

- 디스패처서블릿과 컨트롤러 사이의 호출방법
  - 디스패처서블릿은 컨트롤러에 담은 정보를 모른다. 대신 컨트롤러 종류에 따라 적절한 어댑터를 사용한다. 각 어댑터는 담당 컨트롤러에 맞는 호출방식을 사용해서 컨트롤러에 작업 요청을 보내고 결과를 돌려받아서 디스패처서블릿에게 돌려준다. 
  - 디스패처서블릿이 핸들러 어댑터에 웹 요청을 전달할 때는 모든 웹 요청 정보가 담긴 HttpServletRequest 타입의 오브젝트를 전달해준다. 이것을 어댑터가 적절히 변환해서 컨트롤러의 메소드가 받을 수 있는 파라미터로 전달해주는 것이다. 

<br/>

3) 컨트롤러의 모델 생성과 정보 등록. 컨트롤러가 디스패처서블릿에게 돌려줘야할 두 가지정보는 모델과 뷰이다. 

4) 컨트롤러 결과 리턴: 컨트롤러가 뷰오브젝트를 직접 리턴할 수도있지만 대부분 뷰 논리 이름을 리턴해주면 뷰리졸버가 이것을 사용해서 뷰 오브젝트를 생성해준다. 이 때 뷰를 사용하는 전략과 리턴방법도 다양하다. 

5) 디스패처서블릿이 컨트롤러에게 모델과 뷰를 받으면, 뷰 오브젝트에게 모델을 전달해주고, 클라에게 돌려줄 최종 결과물을 생성해달라고 요청한다. 뷰 작업을 통한 최종결과물은 HttpServletResponse 오브젝트에 담긴다.

6) 디스패처서블릿은 등록된 후처리기가 있으면 후속작업 진행 후에, HttpServleResponse에 담긴 최종 결과를 서블릿컨테이너에게 돌려준다. 서블릿 컨테이너는 이 결과정보를 HTTP 응답으로 만들어서 클라에게 전송하고 작업이 종료된다.

<br/>

#### 디스패처서블릿에는 DI로 확장할 수 있는 전략이있다.

- HandlerMapping (URL과 요청정보 기준으로 어떤 컨트롤러를 사용할 지 결정하는 로직 담당)
- HandlerAdapter (선택한 컨트롤러를 디스패처서블릿이 호출할 때 사용함)
  - 컨트롤러 타입에 적합한 어댑터를 사용해서 호출한다. 디폴트로 등록되어 있는 핸들러어댑터는 'HttpRequestHandlerAdapter', 'SimpleControllerHandlerAdapter', 'AnnotationMethodHandlerAdapter' 3가지이다. 
- HandlerExceptionResolver (예외 발생 시 처리하는 로직 담당)
  - 디스패처서블릿은 발생한 예외에 적합한 핸들러익셉션리졸버를 찾아서 예외처리를 위임한다. 디폴트 전략은 'AnnotationMethodHandlerExceptionResolver', 'ResponseStatusExceptionResolver', 'DefaultHandlerExceptionResolver' 세 가지가 등록되어있다. 
- ViewResolver (컨트롤러가 리턴한 뷰 이름 참고해서 적절한 뷰 오브젝트 찾아주는 로직 담당)
- LocaleResolver (지역정보 결정)
  - 디폴트는 'AcceptHeaderLocaleResolver'. HTTP 헤더정보를 보고 지역정보 설정해준다. 
- ThemeResolver (테마정보 결정해주는 전략)
- RequestToViewNameTranslator (컨트롤러에서 뷰이름이나 뷰 오브젝트를 제공해주지 않았을 경우 URL과 같은 요청정보를 참고해서 자동으로 뷰 이름을 생성해줌)

<br/>

> #### 디스패처서블릿은 각 전략의 디폴트 설정을 Dispatcher.properties라는 전략 설정파일에서 가져와서 초기화한다. 위 전략을 통해 디스패처서블릿의 동작방식을 확장 가능하다. 
>
> 디스패처서블릿은 서블릿컨테이너가 생성하고 관리하는 오브젝트이고 스프링의 컨텍스트에서 관리하는 빈 오브젝트가 아니다. 따라서 디스패처서블릿에 직접 DI설정은 할 수 없다. 대신 내부에 서블릿 웹 어플리케이션 컨텍스트를 갖고 있고 여기에 개발자가 전략을 추가하거나 설정을 수정한 빈 오브젝트를 담을 수 있다. 추가해준 빈이있으면 이것을 디폴트전략 대신 가져와서 사용한다. 
