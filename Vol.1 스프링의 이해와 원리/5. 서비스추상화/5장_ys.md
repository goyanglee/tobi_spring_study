# 5장. 서비스 추상화

[https://www.notion.so/5-4b3d8f1cf3b24aef8b8e394ca294ab13](https://www.notion.so/5-4b3d8f1cf3b24aef8b8e394ca294ab13)

# 5.1 사용자 레벨의 관리 추가

## 5.1.1 필드 추가

### Level 이늄

```java
public enum Level {
BASIC(1), SILVER(2), GOLD(3);

}
```

## 5.1.5 코드 개선

- 코드에 중복된 부분은 없는가?
- 코드가 무엇을 하는 것인지 이해하기 불편하기 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

user 테스트 ← 참고 

# 5.2 트랜잭션 서비스 추상화

## 5.2.1 모아니면 도

## 5.2.2 트랜잭션 경계 설정

DB는 완벽한 트랙잭션을 보장해준다.

하지만 여러개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야하는 경우도 있다.

<DB의 트랜잭션 작업이 끝나는 방법의 두가지>

트랜잭션 롤백 : 하나의 SQL을 취소하면 앞에서 처리한 SQL 작업도 취소시켜야한다.

트랜잭션 커밋 : 모든 SQL 작업이 성공하면 수행작업이 마무리됐다고 DB에게 알려줘서 작업을 확정시켜야 한다.

### **JDBC 트랜잭션의 트랜잭션 경계설정**

모든 트랜잭션은 한 가지의 시작 지점과 두 가지의 끝나는 지점이 있다. 

**JDBC의 트랜잭션은 하나의 Connection을 가져와 사용하다가 닫는 사이에서 일어난다.**

트랜잭션의 시작과 종료는 Connection 오브젝트를 통해 이뤄지기 때문이다. 

JDBC에서 트랜잭션을 시작 : 

Connection의 setAutoCommit(false) :  자동커밋 옵션을 false로

트랜잭션이 한 번 시작되면 commit() 또는 rollbak() 메소드가 호출 될 때까지의 작업이 하나의 트랜잭션으로 묶인다.

이렇게 **setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 종료하는 작업을 트랜잭션의 경계설정Transaction Demarcation이라고 한다.** 

이렇게 하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 **로컬 트랜잭션Local Tranaction**이라고도 한다.

### UserService와 UserDao의 트랜잭션 문제

일반적으로 트랜잭션은 커넥션보다도 존재의 범위가 짧다.

따라서 템플릿 메소드가 호출될 때마다 트랜잭션이 새로 만들어지고 메소드를 빠져나오기 전에 종료된다.

결국 JdbcTemplate의 메소드를 사용하는 UserDao는 각 메소드마다 하나씩의 독립적인 트랜잭션으로 실행될 수 밖에 없다.

![5%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20350fecfa5c944a10857cf0c02dbb6b24/Untitled.png](5%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%AA%20350fecfa5c944a10857cf0c02dbb6b24/Untitled.png)

### 비즈니스 로직 내의 트랜잭션 경계 설정