
# Subject
• 스프링 프레임워크가 무엇인지 이해한다.<br/>
• 관심사에 대해 이해한다.<br/>
• 결합도와 책임에 대해 이해한다.<br/>
• 전략패턴에 대해 이해한다.<br/>
• IoC에 대해 이해한다.<br/>
• 싱글톤의 장단점을 이해하고 해결책을 제시할 수 있다.<br/>
• DI의 개념과 적용 방법에 대해 이해한다.<br/>
• 객체 지향에 대해 이해한다.<br/>


# 스프링이란?

스프링은 자바를 기반으로 한 기술이다. 자바의 객체 지향적 사고를 중요하게 생각했다. 자바 엔터프라이즈 기술에서 객체 지향 기술의 기본으로 돌아가자는 철학을 가지고 있다.<br/>
<br/>
• 자바의 엔터프라이즈 기술은?
Java EJB (Enterprise Java Bean) = J2EE (Java 2 Enterprise Edition)
Sun MicroSystems는 IBM, Oracle, HP 등 여러 벤더들도 적용할 수 있는 모든 스펙들을 모아뒀다.

## 대표 구성 요소

1. 서블릿
2. JSP
3. EJB(Enterprise Java Beans) 자바에서 제공하는 분산 컴포넌트 기술.
4. JDBC
5. RMI(Remote Method Invocation) 프록시로 원격에 있는 자바 메소드를 실행
6. JNDI (Java Naming DirectoryInterface) 객체에 이름을 붙여 찾을 수 있도록 한다.
7. JCA (Java Connector Architecture) 다른 플랫폼을 통합할 수 있도록 플랫폼 독립 인터페이스를 제공한다.
8. JMS(Java MEssage Service) 여러 메시징 시스템에 대한 플랫폼 독립 인터페이스 제공
EJB사양은 자바ee의 api중 하나로, 업무 로직을 처리하는 역할을 한다.

## EJB 종류

1. 세션 빈 (session bean)
2. 엔티티 빈 (entity bean)
3. 메시지 구동 빈 (message driven bean)

분산환경을 지원한다는 장점이 있지만 이 때문에 객체를 직렬화하는 과정이 있어서 실행 속도가 저하가 되고 빌드와 배포, 테스트가 어렵다.

때문에 스프링이 가장 관심을 두는 것이 바로 “오브젝트” 이다.

• 자바빈의 생성 방법 : 디폴트 생성자, 프로퍼티(setter, getter)

# 제어의 역전으로 가는 길

1. 관심사의 분리 (separation of concerns)
변경이 일어났을 때 필요한 작업을 최소화할 수 있는 방법이 뭐가 있을까? 단지 db접속용 암호를 변경하려고 모든 dao를 수정하지 않을 수 있는 방법은?
관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 영향을 안주도록 분리한다. 어떻게 분리할까?
    1. 중복 코드의 메소드를 추출한다.
    2. 상속을 활용할 수 있도록 추상화시킨다. 같은 코드를 확장해서 각기 다른 사이트에서 사용할 수 있다.
    A. 오버라이딩할 수 있도록 protected 메소드로 만든다. = 템플릿 메소드 패턴
    B. 추상클래스를 확장한 객체A를 만들어지고, 이 추상클래스가 상속하고 있는 인터페이스는 객체 A를 쓸지 객체 b를 쓸지 결정한다. 즉, 추상클래스는 인터페이스의 메소드를 사용하는 것에 관심이 있고, 추상클래스를 확장한 객체가 오버라이딩하기 위해 인터페이스에서 어떻게 기능을 제공하는지에 관심이 있다. 슈퍼클래스는 하위 클래스에서 어떤 오브젝트를 만들어 리턴할 지 모르고, 하위 클래스는 언제든 오브젝트 생성을 재정의할 수 있다. 미리 정의해둔 메소드를 팩토리 메소드라고 하고 오브젝트 생성을 슈퍼클래스로부터 독립시키는 것을 팩토리 메소드 패턴이라고 한다.= 팩토리 메소드 패턴

단, 상속을 사용함으로서 다른 기능을 사용할 수 없게 될 수 있다는 단점이 있다.

? JDB API 와 DB API

2. 클래스의 분리

상속이라는 과정을 거치지 않고 하나의 클래스에 전부 담는다. → 다른 사이트에 제공하는 식의 장점을 활용할 수 없게 되었다. → 인터페이스를 만들어 느슨하게 만든다. ( 상속과 확장을 이용한 아까의 상황과 비교해서 뭐가 다른가..?)  인터페이스의 어떤 일을 하는지만 알면 어떻게 했는지를 알 필요가 없다. 그렇다고 해도 그 인터페이스를 사용하는 클래스에서 인터페이스를 확장한 클래스를 주입하므로 의존적이게 된다.

3. 관계설정 책임의 분리

그러므로 의존성을 끊고 인터페이스를 상속한 무엇이든 동적으로 연결되게 하려면? 중간자가 필요해진다. 중간자는 인터페이스에 연결해줄 구현 클래스를 생성해서 주입시켜준다. 

4. 객체지향의 패턴

1. 개방 폐쇄 원칙. open-closed principle : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야한다. 높은 응집도와 낮은 결합도라는 원리. 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 
    1. 높은 응집도: 변경이 일어날 때 많은 부분이 함께 바뀐다. 만일 일부만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하고, 다른 부분에 어떤 영향을 끼치는 지 알아야한다.
    2. 낮은 결합도: 다른 모듈과 낮은 결합도를 갖는다. 독립적이고 최소한만으로 다른 모듈에 대해 알게 되는 것이다. 하나의 변경이 다른 모듈로 옮겨가지 않는다. 
2. 단일 책임 원칙(Single Responsibility Principle) 
3. 리스코프 치환 원칙 LSP (Liskov Substitution Principle)
4. 인터페이스 분리 원칙ISP (Interface Segregation Principle)
5. 의존관계 역전 원칙DIP (Dependency Inversion Principle)

5. 전략 패턴 : 자신의 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘(독립적인 책임으로 분리가 가능한 기능)을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴

# 제어의 역전 (Inversion Of Control)

오브젝트 팩토리라는, 오브젝트를 생성해서 반환하는 기능을 담당하는 메소드 혹은 클래스가 있다. 

제어의 역전은 자신이 사용할 오브젝트를 스스로 선택하지도, 생성하지도 않고 제어 권한을 다른 대상에게 위임해서 그 대상에게서 결정되고 만들어진다.  템플릿 메소드 패턴에서 추상클래스를 상속한 하위 클래스가 메소드를 오버라이딩해서 구현하지만 언제 메소드가 불려서 실행되는지 모르는 것 처럼 제어권을 상위 템플릿 메소드에 넘기고 호출해서 사용하도록 한다는 점이 바로 제어의 역전이다. 

Q. 위에서 설명한 오브젝트 팩토리를 활용해서 어떤걸 생성할지 결정을 하는 과정이 있는데 제어의 역전은 스스로 선택하지 않는다고 하지 않았나? → 구현 클래스를 만들고 결정할 권한을 오브젝트 팩토리에 넘겼으니 userDao는 수동적인 존재가 되었다. 개발자가 오브젝트 팩토리에서 어떤 구현체를 사용할 건지 결정했다. 결정한 이후는 위임하지만 결정하는 순서가 개발자에게 있는데 왜 제어의 역전은 결정하는 과정까지 있어야 제어의 역전이 된다고 할까?

프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 한다. 프레임워크는? 라이브러리도 아니고 준비된 추상 라이브러리의 집합도 아니다. 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자의 코드를 사용하도록 만드는 방식이다.

## IoC
bean : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트. 엔터프라이즈 자바빈에서 말하는 빈과 유사하다. 
빈 팩토리 : bean을 만들고 제어를 담당한다.
어플리케이션 컨텍스트 : 빈 팩토리를 더 확장한 개념. 빈 팩토리의 기본 기능 + 앱 전반에 걸처 모든 구성요소의 제어 작업을 담당하는 IoC 엔진

설정정보로 만드는 과정
1. @Configuration 추가 : 어플리케이션 컨텍스트 혹은 빈 팩토리가 사용할 설정정보라는 표시
2. @Bean 추가 : 오브젝트 생성을 담당하는 IoC용 메소드위에 선언. 메소드 이름이 빈의 이름이 된다.

ApplicationContext를 구현한 클래스 중 하나 : AnnotationConfigApplicationContext
getBean() 을 통해 위에서 @bean을 한 빈이 반환이 되는데 기본 타입은 Object이다.

### 애플리케이션 컨텍스트의 동작방식 = IoC 컨테이너 = 빈팩토리
장점 :
1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다. (이해가 안감)
2. 종합 IoC 서비스를 제공한다. 오브젝트가 만들어지는 방식, 시점, 전략, 후처리, 설정방식 변경, 인터셉팅 등의 기능을 제공한다. 빈이 사용할 수 있ㄴㄴ 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해주기도 한다.(?)
3. 빈을 찾는 여러 방법을 제공한다.

### IoC 용어
1. 빈 : IoC방식으로 관리하는 오브젝트. 모든 오브젝트가 빈은 아니고 스프링이 직접 생성과 제어를 담당하는 오브젝트
2. 빈 팩토리 : IoC를 담당하는 핵심 컨테이너. 빈의 주기를 관리한다.
3. 애플리케이션 컨텍스트 : 빈 팩토리를 확장한 IoC 컨테이너.
4. 설정정보 / 설정 메타 정보 : 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보. configuration이라고 하고 오브젝트를 생성하고 구성할 때 사용한다.
5. 컨테이너 또는 IoC 컨테이너 : IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다. 보통 하나의 애플리케이션에서 여러 개가 만들어져 사용된다.
6. 스프링 프레임워크 : IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용한다.

## 싱글톤 레지스트리와 오브젝트 스코프
• 동일성과 동등성 <br/>
동일성 : 오브젝트가 완전히 동일하다. == 연산자를 사용. 사실은 하나의 오브젝트만 존재하고 두개의 오브젝트 레퍼런스 변수를 가진 것이다.<br/>
동등성 : 동일한 정보를 가지고 있다. equals() 를 사용<br/>

### 애플리케이션 컨텍스트는 싱글톤으로 관리하는 싱글톤 레지스트리이기도 하다.
why? 초기 대규모 서버 시스템을 위해 설계된 스프링은, 요청이 들어올 때마다 새로 오브젝트를 새로 생성하는 것이 부담이었다. 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트인데 강제는 아니지만 대부분 멀티 스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스 당 하나의 오브젝트만 만들어두고 여러 스레드에서 공유한다.

단,
1. 싱글톤 패턴은 생성자가 private으로 제한되기 때문에 상속할 수 없다.
2. 만들어지는 방식이 제한적이기 때문에 mock 오브젝트 등으로 대체하기 어렵다.
3. 클래스로더 구성에 따라 싱글톤이 완전히 보장되지는 않는다. (?)
4. 싱글톤은 static으로 만들어지기 때문에 어디서든 접근이 가능해서 권장되지 않는 모델이다.

이런 문제점들이 많기 때문에 스프링은 “싱글톤 레지스트리” 로 직접 싱글톤 형태의 오브젝트를 관리한다. 위와 같이 static, private 을 사용해야하는 좋지 않은 방식 대신에 평범한 클래스를 싱글톤으로 활용하게 해준다. public 생성자도 가능하고 테스트환경에서 자유롭게 만들 수 있으며 mock 오브젝트로 대체도 가능하다. 싱글톤 패턴의 단점을 보완하고 스프링이 지향하는 객체지향적 설계방식을 따른다. 

• 주의할 점
싱글톤은 멀티쓰레드라면 여러 스레드가 동시에 접근할 수 있다. 그러므로 상태정보를 내부에 가지고 있지 않아야 한다.(stateless) 동시에 인스턴스 변수를 수정하면 위험하기 때문이다. 그렇기 떄문에 db 서버 정보와 같은 것들은 어떻게 처리할까? 메소드 안에 생성되는 로컬변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 로컬변수에 파라미터를 통해 생성해준다.(Q. 스레드가 동시에 접근할 수 있다면 객체가 하나고 힙 메모리에 저장이 될 텐데 로컬변수 여러개를 하나의 객체가 어떻게 관리를 하지?)

### 빈의 스코프는 스프링이 관리하는 빈이 생성되고 존재하고 적용되는 범위를 의미한다.
* 빈의 기본 스코프는 싱글톤 스코프이다. 스프링 컨테이너가 존재하는 동안 계속 유지된다. 
* 프로토타입 스코프 : 빈이 요청할 때마다 매번 새로운 오브젝트를 만든다.
* request 스코프
* 세션 스코프

## 스프링 IoC의 핵심은 DI 이다.
스프링이 제공하는 IoC의 핵심 개념, 차별점은 의존관계 주입(dependency Injection) 이다. -> 이 점이 폭넓게 사용되는 IoC가 스프링에 적용되었을 때 더 구체화될 수 있는 포인트이다. 그래서 초기에는 IoC 컨테이너로 불리던 것이 지금은 DI 컨테이너라고 불리우고 있다. 외부로부터 주입받고 다른 오브젝트들과 다이나믹하게 의존관계가 만들어지는 것이 핵심이다.

# 의존한다는 것은 의존 대상이 변하면 의존하고 있는 오브젝트에 영향을 미친다는 의미이다.

의존관계의 조건
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.
2. 런타임 시점의 의존관계는 컨테이너나 팩토리같은 제 3의 존재가 결정한다. (애플리케이션 컨텍스트, IoC 컨테이너)
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로서 만들어진다.

## 스프링 IoC 방법에는 의존관계 검색(=DL. Dependency Lookup) 도 있다.
능동적으로 자신이 필요로 하는 의존 오브젝트를 찾는다. 미리 정해놓은 이름을 전달해서 오브젝트를 검색한다.
좋은 방법은 아니다. 애플리케이션 컴포넌트가 컨테이너와 같이 성격이 다른 오브젝트에 의존하게 되는 것이기 때문이다.(?) 따라서 의존관계 주입 방식을 사용하는 것이 나은데, 의존 관계 검색이 필요한 순간이 있긴 하다. 적어도 한번은 오브젝트를 가져와야할 일이 생기기 떄문이다. 스태틱 메소드에서는 오브젝트를 주입받을 방법이 없다. 즉, 의존관계 검색 방식에서는 검색하는 오브젝트가 스프링의 빈일 필요가 없다! 주입에서는 반드시 빈 오브젝트여야 한다. 

## DI 의 장점
1. 결합도가 낮아 의존 대상이 바껴도 영향을 받지 않는다.

## 의존관계를 만드는 방법
1. 수정자 메소드 setter
2. 일반 메소드

## DI 를 XML 로 설정하기
### <beans> 안에 <bean> = @configuration 안에 @bean
### @Bean을 통해 얻는 정보
1. 빈의 이름 : 메소드의 이름이 빈의 이름이다.
2. 빈의 클래스
3. 빈의 의존 오브젝트 : 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어준다.
4. 수정자 메소드는 set을 제외한 나머지가 프로퍼티가 된다.

|info|자바 코드 설정 정보 | xml 설정 정보|
|-----|-—--------------|—----------|
|빈 설정 파일|@configuration|<beans>|
|빈의 이름|@Bean methodName()|<bean id=“methodName”|
|빈의 클래스|return new BeanClass();|class=“a.b.c...BeanClass”>| <br/>
이때 빈의 클래스는 오브젝트를 만들 때 사용하는 클래스 이름이다.  메소드의 리턴 타입을 class 애트리뷰트에 사용하지 않는다.(? 뭐가 다른거지?)

<property name = “connectionMaker” ref=“connectionMaker”/>
= userDao.setConnectionMaker(connectionMaker());
프로퍼티 이름은 바뀔 수 있는 클래스 이름보다는 인터페이스의 이름을 따르는 편이 자연스러워서 보통 그렇게 쓴다.

### XML 로 애플리케이션 컨텍스트 만들기
genericXmlApplicationContext를 사용하고, 파라미터로 xml 파일의 클래스패스를 지정해주면 된다. /가 없어도 항상 루트에서부터 시작한다.
그 외에 ClassPathXmlApplicationContext를 이용할 수 있다. xml파일이 있는 경로에 있는 오브젝트에 대한 정보도 같이 넘겨서 경로를 유추하게 한다. 웬만하면 GenericXmlApplicationContext를 사용한다.

### 이미 정의되어 있는 DataSource 인터페이스
확장한 SimpleDriverDataSource 를 테스트환경에서 간단히 사용할 수 있다.

### 프로퍼티 값 주입
위에서 작성한 ref와 기능이 동일하지만 다른 빈 오브젝트의 레퍼런스가 아니라 단순 값을 주입해주는 경우에는 value 애트리뷰트를 사용한다.
-> 수정자 메소드의 파라미터 타입을 참고해서 string이든 int 이든 변환해준다. File, Url 같은 오브젝트로도, list, map 같은 컬렉션 타입으로도 가능하다.

