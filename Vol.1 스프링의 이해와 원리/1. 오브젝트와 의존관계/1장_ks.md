# 스프링이란?

스프링은 자바를 기반으로 한 기술이다. 자바의 객체 지향적 사고를 중요하게 생각했다. 자바 엔터프라이즈 기술에서 객체 지향 기술의 기본으로 돌아가자는 철학을 가지고 있다.

• 자바의 엔터프라이즈 기술은?
Java EJB (Enterprise Java Bean) = J2EE (Java 2 Enterprise Edition)
Sun MicroSystems는 IBM, Oracle, HP 등 여러 벤더들도 적용할 수 있는 모든 스펙들을 모아뒀다.

## 대표 구성 요소

1. 서블릿
2. JSP
3. EJB(Enterprise Java Beans) 자바에서 제공하는 분산 컴포넌트 기술.
4. JDBC
5. RMI(Remote Method Invocation) 프록시로 원격에 있는 자바 메소드를 실행
6. JNDI (Java Naming DirectoryInterface) 객체에 이름을 붙여 찾을 수 있도록 한다.
7. JCA (Java Connector Architecture) 다른 플랫폼을 통합할 수 있도록 플랫폼 독립 인터페이스를 제공한다.
8. JMS(Java MEssage Service) 여러 메시징 시스템에 대한 플랫폼 독립 인터페이스 제공
EJB사양은 자바ee의 api중 하나로, 업무 로직을 처리하는 역할을 한다.

## ## EJB 종류

1. 세션 빈 (session bean)
2. 엔티티 빈 (entity bean)
3. 메시지 구동 빈 (message driven bean)

분산환경을 지원한다는 장점이 있지만 이 때문에 객체를 직렬화하는 과정이 있어서 실행 속도가 저하가 되고 빌드와 배포, 테스트가 어렵다.

때문에 스프링이 가장 관심을 두는 것이 바로 “오브젝트” 이다.

• 자바빈의 생성 방법 : 디폴트 생성자, 프로퍼티(setter, getter)

# <제어의 역전으로 가는 길>

1. 관심사의 분리 (separation of concerns)
변경이 일어났을 때 필요한 작업을 최소화할 수 있는 방법이 뭐가 있을까? 단지 db접속용 암호를 변경하려고 모든 dao를 수정하지 않을 수 있는 방법은?
관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 영향을 안주도록 분리한다. 어떻게 분리할까?
    1. 중복 코드의 메소드를 추출한다.
    2. 상속을 활용할 수 있도록 추상화시킨다. 같은 코드를 확장해서 각기 다른 사이트에서 사용할 수 있다.
    A. 오버라이딩할 수 있도록 protected 메소드로 만든다. = 템플릿 메소드 패턴
    B. 추상클래스를 확장한 객체A를 만들어지고, 이 추상클래스가 상속하고 있는 인터페이스는 객체 A를 쓸지 객체 b를 쓸지 결정한다. 즉, 추상클래스는 인터페이스의 메소드를 사용하는 것에 관심이 있고, 추상클래스를 확장한 객체가 오버라이딩하기 위해 인터페이스에서 어떻게 기능을 제공하는지에 관심이 있다. 슈퍼클래스는 하위 클래스에서 어떤 오브젝트를 만들어 리턴할 지 모르고, 하위 클래스는 언제든 오브젝트 생성을 재정의할 수 있다. 미리 정의해둔 메소드를 팩토리 메소드라고 하고 오브젝트 생성을 슈퍼클래스로부터 독립시키는 것을 팩토리 메소드 패턴이라고 한다.= 팩토리 메소드 패턴

단, 상속을 사용함으로서 다른 기능을 사용할 수 없게 될 수 있다는 단점이 있다.

? JDB API 와 DB API

2. 클래스의 분리

상속이라는 과정을 거치지 않고 하나의 클래스에 전부 담는다. → 다른 사이트에 제공하는 식의 장점을 활용할 수 없게 되었다. → 인터페이스를 만들어 느슨하게 만든다. ( 상속과 확장을 이용한 아까의 상황과 비교해서 뭐가 다른가..?)  인터페이스의 어떤 일을 하는지만 알면 어떻게 했는지를 알 필요가 없다. 그렇다고 해도 그 인터페이스를 사용하는 클래스에서 인터페이스를 확장한 클래스를 주입하므로 의존적이게 된다.

3. 관계설정 책임의 분리

그러므로 의존성을 끊고 인터페이스를 상속한 무엇이든 동적으로 연결되게 하려면? 중간자가 필요해진다. 중간자는 인터페이스에 연결해줄 구현 클래스를 생성해서 주입시켜준다. 

4. 객체지향의 패턴

1. 개방 폐쇄 원칙. open-closed principle : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야한다. 높은 응집도와 낮은 결합도라는 원리. 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 
    1. 높은 응집도: 변경이 일어날 때 많은 부분이 함께 바뀐다. 만일 일부만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하고, 다른 부분에 어떤 영향을 끼치는 지 알아야한다.
    2. 낮은 결합도: 다른 모듈과 낮은 결합도를 갖는다. 독립적이고 최소한만으로 다른 모듈에 대해 알게 되는 것이다. 하나의 변경이 다른 모듈로 옮겨가지 않는다. 
2. 단일 책임 원칙(Single Responsibility Principle) 
3. 리스코프 치환 원칙 LSP (Liskov Substitution Principle)
4. 인터페이스 분리 원칙ISP (Interface Segregation Principle)
5. 의존관계 역전 원칙DIP (Dependency Inversion Principle)

5. 전략 패턴 : 자신의 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘(독립적인 책임으로 분리가 가능한 기능)을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴

# 제어의 역전 (Inversion Of Control)

오브젝트 팩토리라는, 오브젝트를 생성해서 반환하는 기능을 담당하는 메소드 혹은 클래스가 있다. 

제어의 역전은 자신이 사용할 오브젝트를 스스로 선택하지도, 생성하지도 않고 제어 권한을 다른 대상에게 위임해서 그 대상에게서 결정되고 만들어진다.  템플릿 메소드 패턴에서 추상클래스를 상속한 하위 클래스가 메소드를 오버라이딩해서 구현하지만 언제 메소드가 불려서 실행되는지 모르는 것 처럼 제어권을 상위 템플릿 메소드에 넘기고 호출해서 사용하도록 한다는 점이 바로 제어의 역전이다. 

Q. 위에서 설명한 오브젝트 팩토리를 활용해서 어떤걸 생성할지 결정을 하는 과정이 있는데 제어의 역전은 스스로 선택하지 않는다고 하지 않았나? → 구현 클래스를 만들고 결정할 권한을 오브젝트 팩토리에 넘겼으니 userDao는 수동적인 존재가 되었다. 개발자가 오브젝트 팩토리에서 어떤 구현체를 사용할 건지 결정했다. 결정한 이후는 위임하지만 결정하는 순서가 개발자에게 있는데 왜 제어의 역전은 결정하는 과정까지 있어야 제어의 역전이 된다고 할까?

프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 한다. 프레임워크는? 라이브러리도 아니고 준비된 추상 라이브러리의 집합도 아니다. 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자의 코드를 사용하도록 만드는 방식이다.
