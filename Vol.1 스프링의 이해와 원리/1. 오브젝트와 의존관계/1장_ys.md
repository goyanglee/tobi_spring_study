# 1장. 오브젝트와 의존관계

Notion : [https://www.notion.so/1-08761e31b00f4c25bd9a92f2b11a7375](https://www.notion.so/1-08761e31b00f4c25bd9a92f2b11a7375)

스프링 핵심 철학 = 객체지향 기술의 진정한 가치를 회복시키고 그로부터 객체지향의 기본을 돌아가자는 것.

앞으로 주의 깊게 살펴봐야 할 것

- 애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고, 소멸하기까지의 전 과정
- 오브젝트는 어떻게 설계되어야 하는 지
- 어떤 단위로 만들어지며 어떤 과정을 통해 자신의 존재를 드러내고 등장해야 하는 지

# 1.1 초난감 DAO

### DAO(Data Access Object)

: DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

## 1.1.1 User

### 자바빈(빈)

요즘의 자바빈은 두가지 관례에 따라 만들어진 오브젝트를 가리킨다.

- 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
- 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

## 1.1.2 UserDao

JDBC를 이용하는 작업의 일반적인 순서

1. DB 연결을 위한 connection을 가져온다.
2. SQL을 담은 Statement(또는 PreparedStatement)를 만든다.
3. 만들어진 Statement를 실행한다.
4. 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트(ex.User)에 옮겨준다.
5. 작업 중에 생성된 Connection, Statement,ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다.
6. JDBC API가 만들어내는 예외(Exception)을 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.

예외는 메소드 밖으로 던져버리는 편이 간단하다.

```java
public void add(User user) throws ClassNotFoundException, SQLException {
	Class.forName("com.mysql.jdbc.Driver");
  Connection c = DriverManager.getConnection(
            "jdbc:mysql://localhost/spring","spring","book");

  PreparedStatement ps = c.prepareStatement(
       "insert into users(id,name,password) values(?,?,?)");
 
  ps.setString(1, user.getId());
  ps.setString(2, user.getName());
  ps.setString(3, user.getPassword();

  ps.executeUpdate();

  ps.close();
  c.close();
}
```

## 1.1.3 main()을 이용한 DAO 테스트 코드

static main() : 모든 클래스에 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 것

사용할 DB의 드라이버를 클래스패스에 넣어주는 일 : db connector jar 파일.

스프링을 내가 공부해야 하는 이유

1. 코드에 문제가 많은가?
2. 많다면 왜 많은가?
3. 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘까?
4. 개선했을 때의 장점은 무엇일까?
5. 장점들이 당장에, 미래에 주는 유익은 무엇인가?
6. 또, 객체지향 설계의 원칙과는 무슨 상관이 있을까?
7. 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에는 무슨 차이가 있을까?

와 같은 문제 제기와 의문에 대한 답을 찾아가는 과정.

# 1.2 DAO 분리

## 1.2.1 관심사의 분리

> 분리와 확장을 고려한 설계

* 분리 :  관심사의 분리

: 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리해야 하는 것 

ex) 모든 dao에 db접속 정보코드를 놓는다면, db 접속 비밀번호가 바뀌면 dao 전부를 수정해야 한다.

## 1.2.2 커넥션 만들기의 추출

### UserDao의 관심사항

- 커넥션(어떤 DB, 어떤 드라이버, 어떤 로그인 정보, 커넥션 생성 방법)
- Statement(SQL 바인딩)
- 오브젝트를 닫아서 공유리소스를 시스템에 돌려주는 것.

### 중복 코드의 메소드 추출

예를 들면 DB Connection처럼 계속 중복되는 코드는 추출해서 새로운 메소드를 만들 것.

### 변경사항에 대한 검증: 리팩토링과 테스트

리팩토링에서는, 이런 것을 메소드 추출 기법이라고 부른다.

: 기능은 그대로이지만, 코드구조와 구현 방법을 바꿈으로 써 더 나은 코드를 만드는 것.

**리팩토링**

 : 외부의 동작 방식에는 변화없이 내부 구조를 변경해서 재구성하는 작업 또는 기술

코드를 더 이해하기 편해지게, 변화에 효율적으로 대응할 수 있게.

생산성은 올리고 코드의 품질은 높아지며, 유지보수에 용이해지고, 견고하면서도 유연한 제품이 될 수 있도록.

## 1.2.3 DB 커넥션 만들기의 독립

### 상속을 통한 확장

**디자인 패턴**: 재사용 가능한 솔루션

패턴에서 가장 중요한 것은 패턴의 핵심이 담긴 목적 또는 의도다.

패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지.

**템플릿 메소드 패턴** : 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법.

변하지 않는 기능은 슈퍼클래스에, 자주 변경되며 확장할 기능은 서브클래스에.

슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등을 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법의 디자인패턴

**훅 메소드** : 슈퍼클래스에 디폴트 기능을 정의해두거나 비웠ㄷ가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어둔 메소드 

**팩토리 메소드 패턴** : 템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴.

서브클래스에서 구체적인 오브젝트 생성방법을 결정하게 하는 것.

= 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드 라고 하고, 이 방식을 통해 오브젝트는 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다. 

### 상속의 문제점

: 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다,

그래서 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함게 수정하거나 다시 개발해야 할 수도 있다.

반대로 그런 변화에 따른 불편을 주지 않기 위해 슈퍼클래스가 더 이상 변화하지 않도록 제약을 가해야 할지도 모른다.

# 1.3 DAO의 확장

## 1.3.1 클래스의 분리

독립적인 클래스로 분리

## 1.3.2 인터페이스의 도입

**추상화** 

: 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업

자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스

**인터페이스** 

: 어떤 일을 하겠다는 기능만 정의해놓은 것. 

인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다.

어떻게 하겠다는 구현방법은 나타나있지 않다.

## 1.3.3 관계설정 책임의 분리

오브젝트와 오브젝트 사이의 관계를 설정

: 오브젝트 내 클래스와는 직접적인 관계를 가져서는 안된다.

클래스 사이에 관계가 맺어진 것과, 단지 오브젝트 사이에 다이내믹한 관계가 만들어지는 것에 대한 차이를 잘 구분할 수 있어야 한다. 

**다형성이란 특징을 이용,**

구현 클래스의 오브젝트 간 관계를 맺는 것에 대한 책임을 클라이언트에게 넘겨버리는 것.

## 1.3.4 원칙과 패턴

개방 폐쇄 원칙(OCP: Open-Closed Principle)

: 클래스나 모듈은 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.

UserDao는 DB 연결 방법이라는 기능을 확장하는데는 열려있어야 하고, UserDao 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지않고 유지할 수 있으므로 변경에는 닫혀있다.

객체지향 설계 원칙 SOLID

SRP(The Single Responsibillity Principle) : 단일 책임 원칙

OCP(The Open Closed Principle) : 개방 폐쇄 원칙

: 높은 응집도와, 낮은 결합도. 

LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙

ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙

DIP(The Dependency Inversion Principle) : 의존 관계 역전 원칙

디자인패턴

: 특별한 상황에서 발생하는 문제에 대한 좀 더 구체적인 솔루션

객체지향 설계 원칙

: 좀 더 일반적인 상황에서 적용 가능한 설계 기준

**전략패턴: 디자인 패턴의 꽃**

: 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘(독릭접인 책임으로 분리가 가능한 기능) 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴.

# 1.4 제어의 역전(IOC)

## 1.4.1 오브젝트 팩토리

### 팩토리

객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 하는 오브젝트

: 단지, 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용.

### 설계도로서의 팩토리

: 애플리케이션의 오브젝트들을 구성하고, 그 관계를 정의하는 책임을 맡고 있음. : 애플리케이션의 컴포넌트 역할

![1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A9%E1%84%87%E1%85%B3%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%2080cdbf62c3c742b6a980d1df4358bb4c/Untitled.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A9%E1%84%87%E1%85%B3%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%2080cdbf62c3c742b6a980d1df4358bb4c/Untitled.png)

## 1.4.2 오브젝트 팩토리의 활용

생성하는 코드도 중복된다면, 생성하는 클래스를 만들고 중복 코드를 제거하여 사용.

## 1.4.3 제어권의 이전을 통한 제어관계 역전

### 제어의 역전

: 프로그램의 제어 흐름 구조가 뒤바뀌는 것 : 모든 제어 권한을 자신이 아닌 다른 대상에게 위임.

**템플릿 메소드 패턴**

: 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴

: 제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다.

**라이브러리**

: 

: 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지, 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.

**프레임워크(제어의 역전이 적용된 대표적인 기술)**

: 애플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만든 방식.

애플리케이션 코드가 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 프레임워크

# 1.5 스프링의 IOC

스프링의 핵심 : 빈 팩토리, 또는 애플리케이션 컨텍스트

## 1.5.1 오브젝트 팩토리를 이용한 스프링 IOC

애플리케이션 컨텍스트와 설정 정보

**빈(Bean)**

: 스프링이 제어건을 가지고 직접 만들고 관계를 부여하는 오브젝트

자바빈 또는 엔터프라이즈 자바빈 에서 말하는 빈과 비븟한 오브젝트 단위의 에플리케이션 컴포넌트 + 스프링 컨테이너가 생성과 관계 설정, 사용등을 제어해주는 제어의 역전이 적용된 오브젝트인 스프링 빈

**빈 팩토리(Bean Factory)**

: 빈의 생성과 관계 설정 같은 제어를 담당하는 IOC 오브젝트

: 빈을 생성하고 관계를 설정하는 IOC의 기본 기능

**애플리케이션 컨텍스트(Application Context)**

: 빈 팩토리를 확장

: 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IOC 엔진

: 별도의 정보를 참고해서 빈(오브젝트)의 생성, 관계 설정 등의 제어 작업을 총괄한다.

= IOC 컨테이너 = 스프링 컨테이너

### DaoFactory를 사용하는 애플리케이션 컨테스트

**@Configuration** 

: 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 하는 애노테이션

**@Bean** 

: 오브젝트 생성

## 1.5.2 애플리케이션 컨텍스트의 동작방식

1. 애플리케이션 컨텍스트가 @configuration 이 붙은 클래스를 설정 정보로 등록해두고.
2. @bean 이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다.
3. 클라이언트에서 호출하면, 빈 목록에 요청한 이름이 있는 지 찾고
4. 있다면 빈을 생성하는 메소드를 호출, 오브젝트를 생성시킨 후 돌려준다.

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
- 애플리케이션 컨텍스트는 종합 IOC 서비스를 제공해준다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

## 1.5.3 스프링 IOC의 용어 정리

### 빈

빈 또는 빈 오브젝트 = 스프링이 IOC 방식으로 관리하는 오브젝트라는 뜻

주의할 점 : 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을  빈이라고 부른다, 모든 오브젝트가 다 빈은 아니다

위 정리 참고

### 빈 팩토리

빈을 관리

위 정리 참고

### 애플리케이션 컨텍스트

빈 팩토리를 확장한 IOC 컨테이너 : 빈 팩토리를 상속한다.

빈 관리 + 스프링이 제공하는 각종 부가 서비스를 추가로 제공

위 정리 참고

### 설정 정보/ 설정 메타 정보

애플리케이션 컨텍스트 또는 빈 팩토리가 Ioc를 적용하기 위해 사용하는 메타정보 = Configuration

컨테이너에 어떤 기능을 세팅하거나 조정 

+IOC 컨테이너에 의해 관리 되는 애플리케이션 오브젝트를 생성하고 구성

= 애플리케이션의 형상 정보 = 애플리케이션의 청사진

### 컨테이너 또는 IOC 컨테이너

= 애플리케이션 컨텍스트 

위 정리 참고

### 스프링 프레임 워크

Ioc 컨테이너+ 애플리케이션 컨텍스트 + 스프링이 제공하는 모든 기능

# 1.6 싱글톤 레지스트리와 오브젝트 스코트

== 동일성 : 오브젝트가 완전히 같은 것

equals() 동등성 : 동일한 정보를 가지고 있는 것

new로 계속 생성한 것들은 당연히 동일성을 가질 수 없음

## 1.6.1 싱글 톤 레지스트리로서의 애플리케이션 컨텍스트

애플리케이션 컨텍스트는 직접만드는 팩토리와 비슷한 방식으로 동작하는 Ioc컨테이너와 동시에 싱글톤을 저장하고 관리하는 **싱글톤 레지스트리**다.

스프링은 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글 톤으로 만든다.

여기서 말하는 싱글톤은 디자인 패턴의 싱글톤 패턴과는 개념은 비슷하지만 구현 방법은 확연히 다르다.

### 서버 애플리케이션과 싱글톤

서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

= 스프링이 주요 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문

**싱글톤 패턴**

: 이렇게 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것

**안티 패턴**

: 싱글톤 패턴이 사용하기 까다롭고 여러문제점을 가지고 있어서 싱글톤 패턴을 피해야 한다는 의미

싱글톤 패턴이란

가장 많이 사용되고, 가장 비판을 받는 패턴

어떤 클래스를 어플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴

이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능.

단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용

**자바에서 싱글톤을 구현하는 방법**

- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
- 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

전형 적인 싱글톤 패턴을 적용한 UserDao

```java
public class UserDao{

   private static UserDao INSTANCE;

   private UserDao(ConnectionMaker connectionMaker){
      this.connectionMaker = connectionMaker;
  }

  public static synchronized UserDao getInstance(){
     if(INSTANCE == null) INSTANCE = new UserDao(???);
     return INSTANCE;
  }
}
```

### 싱글톤 패턴의 한계

- private 생성자를 갖고 있기 때문에 상속할 수 없다. : 다형성 적용 불가
- 싱글톤은 테스트하기가 힘들다.
- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다. : JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기때문에 싱글톤으로써의 가치가 떨어진다.
- 싱글톤이 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

### 싱글톤 레지스트리

: 이렇게 싱글톤 패턴의 한계때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는 것.

스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다. 

: 가장 중요한 것은 싱글톤 패턴과는 달리 객체지향적인 설계 방식과 원칙, 디자인 패턴등을 적용하는 데 아무런 제약이 없다. 

## 1.6.2 싱글톤과 오브젝트의 상태

싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서, 상태 관리에 주의를 기울여야 한다.

기본적으로 싱글톤이 멀티스레드 환경에서 오브젝트 형태로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다.

→ 상태변경을 하는 상태유지 방식으로 만들면 매우 위험해짐.

## 1.6.3 스프링 빈의 스코프

# 1.7 의존 관계 주입(DI)

## 1.7.1 제어의 역전(IOC)과 의존 관계 주입

## 1.7.2 런타임 의존 관계 설정

### 의존 관계

### UserDao의 의존관계

### UserDao의 의존관계 주입

## 1.7.3 의존 관계 검색과 주입

## 1.7.4 의존 관계 주입의 응용

### 기능 구현의 교환

### 부가 기능 추가

## 1.7.5 메소드를 이용한 의존 관계 주입

- 수정자 메소드를 이용한 주입
- 일반 메소드를 이용한 주입

# 1.8 XML을 이용한 설정

## 1.8.1 XML 설정

### connectionMaker() 전환

### UserDao() 전환

### XML의 의존관계 주입 정보

## 1.8.2 XML을 이용하는 애플리케이션 컨텍스트

## 1.8.3 DataSource 인터페이스로 변환

### Datasource 인터페이스 적용

### 자바 코드 설정 방식

## 1.8.4 프로퍼티 값의 주입

### 값 주입

### value 값의 자동 변환

# 1.9 정리

내용이 정말 재미없어서.. 힘들었다.....