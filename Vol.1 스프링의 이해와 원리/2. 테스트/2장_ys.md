# 2장. 테스트

[https://www.notion.so/2-74d34ab67c0a48e8a6d4621322b19228](https://www.notion.so/2-74d34ab67c0a48e8a6d4621322b19228)

스프링 개발자에게 제공하는 가장 중요한 가치

: 객체지향과 테스트

# 2.1 UserDaoTest 다시보기

## 2.1.1 테스트의 유용성

테스트 해라!

테스트란, 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는 지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업.

## 2.1.2 UserDaoTest의 특징

- main() 메소드 사용
- 직접 테스트할 대상인 UserDao를 불러서 사용하는 테스트 작성

### 웹을 통한 DAO 테스트 방법의 문제점

- 서비스 클래스, 컨트롤러, jsp 뷰 등 모든 레이어 기능을 만들고나서야 테스트가 가능하다.
- 에러가 나면 어디서 발생했는 지 수고가 필요하다

### 작은 단위의 테스트(Unit Test)

- "관심사의 분리" 라는 원리

### 자동수행 테스트 코드

테스트는 자동 으로 수행되도록 코드로 만들어지는 것이 중요하다. ⇒ 자주 반복할 수 있다.

### 지속적인 개선과 점진적인 개발을 위한 테스트

테스트를 안하면서 코드를 짜면 막판에 굉장히 질린다⇒그래서 내가질리나보다

## 2.1.3 UserDaoTest의 문제점

### 수동 확인 작업의 번거로움

출력 값 확인의 번거로움

### 실행 작업의 번거로움

아무리 간단히 실행 간단한 main() 메소드라해도, 매번 그것을 실행하는 것은 번거롭다. 전체 기능을 확인하기 우이해 수백번 실행해보는 수고가 필요하다. 

⇒ 좀 더 편리하고 체계적으로 테스트를 실행하고 그 결과를 확인하는 방법이 절실히 필요하다. 

# 2.2 UserDaoTest 개선

## 2.2.1 테스트 검증의 자동화

테스트 결과의 검증 부분을 자동화 해보자.

⇒ 객체 비교 출력

xUnit : 포괄적인 테스트는 개발자를 안심할 수 있게 한다.

## 2.2.2 테스트의 효율적인 수행과 결과 관리

테스트 도구 사용으로 단위 테스트 가능

### Junit 테스트로 전환

Junit은 테스트를 위한 프레임워크 

### 테스트 메소드 전환

1. 메소드는 public으로 선언 
2. @Test 애노테이션 사용

### 검증 코드 전환

- junit 라이브러리 추가  : com.springsoure.org.junit-4.7.0.jar

Junit 제공 assertThat 메소드 사용.

= 일치하면 다음으로 넘어가고, 아니면 test 실패 

is() : equals()로 비교해주는 기능

```java
assertThat(user2.getName(), is(user.getName());
```

### Junit 테스트 실행

@Test 가 붙은 메소드를 가진 클래스의 이름을 넣어준다.

```java
JunitCore.main("springbook.user.dao.UserDaoTest");
```

# 2.3 개발자를 위한 테스팅 프레임워크 Junit

### 2.3.1 JUnit 테스트 실행 방법

### IDE

이클립스 > run > Run As > JUnit Test

### 빌드 툴

ANT, Maven 하면 html이나 텍스트 파일의 형태로 보기 좋게 만들어진다.

## 2.3.2 테스트 결과의 일관성

### deleteAll()의 getCount() 추가

- deleteAll() : test 한 데이터는 전부 삭제해준다.
- getCount(): User 테이블의 레코드 개수를 돌려준다.

### deleteAll() 과 getCount()의 테스트

```java
dao.deleteAll()l
assertThat(dao.getCount(),is(0));
```

### 동일한 결과를 보장하는 테스트

db의 동일성은 당연하고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

## 2.3.3 포괄적인 테스트

성의 없는 테스트는 안하느니만 못하다. 한가지 결과만 확인하는 것은 위험하다.

### getCount()테스트

```java
dao.add(user1);
assertThat(dao.getCount(),is(1));
```

JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. ⇒ 모든 테스트는 실행 순서에 상관 없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야 한다.

### addAndGet() 테스트 보완

```java
User userget1 = dao.get(user1.getId());
assertThat(userget1.getName(),is(user1.getName()));
```

### get() 예외 조건에 대한 테스트

EmptyResultDataAccessException 이용

JUnit 예외 조건 테스트

```java
@Test(expected=EmptyResultDataAccessException.class) 
-> 테스트 중에 발생할 것으로 기대하는 예외 클래스를 지정해준다.

dao.get("unkown")// 아무 id나 get해서 exception 이 제대로 발생하는 지 확인한다.
```

### 테스트를 성공시키기 위한 코드의 수정

```java
if(user == null) throw new EmptyResultDataaccessException(1);
```

### 포괄적인 테스트

테스트는 성공할 상황이 아닌, 예외적인 상황에 대한 테스트를 해봐야 한다. 

## 2.3.4 테스트가 이끄는 개발

테스트 할 코드를 먼저 만들어 테스트가 실패하는 것을 보고 나서 UserDao 코드에 손을 대기 시작했다.

### 기능 설계를 위한 테스트

테스트코드 = 잘 작성된 하나의 기능 정의서

### 테스트 주도 개발

**TDD, Test Driven Development**

**또는 테스트 우선 개발 Test First Development**

: 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발

1. 테스트를 빼먹지 않고 꼼꼼하게 만들어 낼 수 있다.
2. 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다.
3. 코드에 대한 피드백을 매우 빠르게 받을 수 있다.
4. 작성한 코드에 대한 확신을 가질 수 있다.

## 2.3.5 테스트 코드 개선

### @Before

: JUnit이 제공하는 어노테이션. @Test 메소드가 실행되기 전에 먼저 실행돼야 하는 메소드를 정의한다.

```java
private UserDao dao; //setUp에서 만드는 오브젝트를 테스트 메소드에서 사용할 수 있도록 인스턴스 변수로 선언한다.

@Before
public void setUp(){
  //먼저 실행되어야 하는 내용 ex) getDao
}
```

**JUnit의 실행 방식**

1. 테스트 클래스에서 @Test가 붙은 public이고 void 형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다. (각 테스트가 서로 영향을 주지 않고 독립적으로 실행되기 위해)
3. @Before 가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

### 픽스처

: 테스트를 수행하는데 필요한 정보나 오브젝트 

: 반복적으로 사용되기 때문에 @before로 만들어두면 좋음

# 2.4 스프링 테스트 적용

애플리케이션 컨텍스트 생성방식에 정리 필요

= 만들어질 때 모든 싱글톤 빈 오브젝트를 초기화하기때문에 제법 많은 시간을 필요로 한다.

## 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

### 스프링 테스트 컨텍스트 프레임워크 적용

```java
@Runwith(SpringJUnit4ClassRunner.class) //JUnit이 제공하는 스프링 테스트 컨텍스트 프레임워크
@ContextConfiguration(location="/applicationContext.xml")// 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
public class UserDaoTest{

    @Autowired
    private ApplicationContext context; //테스트 오브젝트가 만들어지고 나면 스프링 테스트 컨텍스트에 의해 자동으로 값이 주입된다.
}
```

### 테스트 메소드의 컨텍스트 공유

JUnit은 테스트 메소드를 실행할 때 마다 새로운 테스트 오브젝트를 만들고,

그 세개에 실행되는 테스트 컨텍스트는 같아진다.

### 테스트 클래스의 컨텍스트 공유

같은 설정파일로 설정해주면 클래스트끼리도 테스트 컨텍스트를 공유한다.

### @Autowired

스프링 di에 사용되는 어노테이션

@autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.

일반적으로는 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만, 이 경우에는 메소드가 없어도 주입이 가능하다.

또 별도의 DI 설정 없이 필드의 타입 정보를 이용해 빈을 자동으로 가져올 수 있는데, 이런 방법을 **타입에 의한 자동 와이어링** 이라고 한다.

## 2.4.2 DI와 테스트

### 테스트 코드에 의한 DI

DB는 

1. SingleConnectionDataSource 이용

 : 커넥션을 하나만 만들어두고 계속 사용, XML에 DB 설정을 하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다. → 하지만 applicationContext.xml 파일의 내용을 강제로 변경하는 것이기때문에 위험

2. @DirtiesContext 어노테이션 사용 

: 이 어노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.

: 클래스가 아니라 메소드에도 사용가능.

### 테스트를 위한 별도의 DI 설정

테스트 전용 test-applicationContext.xml 생성

### 컨테이너 없는 DI 테스트

그냥 직접해줘도 된다.

DI는 객체지향 프로그래밍 스타일이기때문에 DI를 위해 컨테이너가 반드시 필요한 것은 아니다.

### DI를 이용한 테스트 방법 선택

스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려해보긴 하자~

# 2.5 학습 테스트로 배우는 스프링

학습 테스트 : 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서 테스트를 작성하는 것.

## 2.5.1 학습 테스트의 장점

- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다 : 샘플 코드가 된다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
- 테스트 작성에 대한 좋은 훈련이 된다.
- 새로운 기술을 공부하는 과정이 즐거워진다.

스터디그룹..? 우리..? 헤~

## 2.5.2 학습 테스트 예제

### JUnit 테스트 오브젝트 테스트

hasItem() : 컬렉션의 원소인 지를 검사

### 스프링 테스트 컨텍스트 테스트

nullValue() : 오브젝트가 null인지를 확인해준다.

either().or() : 두 개의 매처 결과를 비교. 하나만 true가 나와도 성공

## 2.5.3 버그테스트

: 오류가 있을 때 그 오류를 가장 잘 드러내 줄 수 있는 테스트 

→ 버그 테스트는 일단 실패하게 만들어야 한다. 

- 테스트의 완성도를 높여준다.
- 버그의 내용을 명확하게 분석하게 해준다
- 기술적인 문제를 해결하는데 도움이 된다.

동등 분할 : 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트 하는 방법.

입력값이나 상황의 조합을 만들어 모든 경우에 대한 테스트를 해보는 것이 좋다.

경계값 분석 : 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트 하는 방법. 보통은 최대값 최소값등으로 테스트