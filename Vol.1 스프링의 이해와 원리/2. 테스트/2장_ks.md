# 학습목표
1. 테스트의 필요성과 작성방법을 설명할 수 있다.
	A. 테스트 주도 개발로 개발시간을 단축한다. 완성도를 높인다.
	B. 설정파일을 사용한다. 어플리케이션 컨텍스트를 공유한다. 사용 오브젝트를 변경한다

# 테스트
## 간단한 복습
스프링은 IoC/DI 를 이용해 객체 지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와주는 기술이다. 

## 테스트 방법
앱 전체를 실행해서 테스트를 하는 방법은, 전체적으로 빌드가 성공적으로 끝나야 하고, 테스트 도중 에러가 발생하면 어디서 발생했는지 코드를 다 따라가며 확인을 해야하는 문제점이 있다.
이를 해결하기 위해서!

1. 작은 단위의 테스트(Unit Test)
관심사의 분리의 원리가 적용된다. 서버 배포도 필요 없고 다른 오브젝트들도 필요없다. 메소드 하나만 테스트할 수도 있다. 단위는 작으면 작을수록 좋다. 

2. 자동수행 테스트 코드
테스트의 전 과정이 자동으로 진행된다. 하나의 테스트를 위해 앱을 실행하고 사전 작업을 하는 번거로움에서 벗어날 수 있다. 수작업을 거치는 방법보다는 자동으로 수행할 수 있어야 하는건 매우 중요하다.

3. 개선과 개발을 위한 테스트

이러한 장점들에도 단점은 있다.

1. 그래도 여전히 눈으로 확인하는 작업이 필요하다.
2. 실행이 간단해도 매번 그것을 실행하는 것은 번거롭다.

# Junit
테스트를 위한 프레임워크. 자바의 표준 테스팅 프레임워크라고 불릴 정도로 폭넓게 사용되고 있다.
요구조건 :
1. 테스트클래스에 실행하는 메소드가 public 으로 선언되어야한다.
2.  @Test 어노테이션을 메소드에 붙여준다.
여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때도 있다. 이럴 때에는 빌드한 뒤에 테스트를 수행하는 것이 좋고, 빌드 스크립트를 이용해 JUnit테스트를 실행하고 그 결과를 메일 등으로 통보받기도 한다.
특정한 테스트 메소드의 실행 순서를 보장하지 않는다.

## 검증법
1. assertThat : 값이 일치하는지 비교
2. 예외가 정상적으로 던져지는지 확인하기
@Test(expected={Exception class})

# 테스트 주도 개발(TDD. Test Driven Development or Test First Development)
테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법
단, 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업 간의 주기를 가능한 짧게 만드는 게 좋다(왜?).
TDD의 장점은 코드를 작성하고 그걸 테스트하는 사이의 간격이 매우 짧다는 것이다.

1. 먼저 수행해야 하는 코드 정리
@Before : @Test 가 실행되기 전에 먼저 실행한다.
## JUnit 테스트 수행 방식
1. 테스트 클래스에서 @Test 가 붙은 public , void형, no parameter 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다
3. @Before 가 붙은 메소드를 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장한다.
5. @After 가 붙은 메소드를 실행한다.
6. 나머지 테스트 메소드에 대해 2-5번을 반복한다.
7. 모든 테스트 결과를 종합해서 반환한다.

@Before, @After는 테스트 메소드에서 직접 호출하지 않기 때문에 주고받을 정보가 있다면 변수를 사용해야한다.
만들어진 테스트 오브젝트는 테스트 메소드를 사용하고 나면 버려진다. 테스트 메소드가 두개 있다면 오브젝트가 두개 만들어지고 버려진다. 왜 메소드마다 오브젝트를 하나씩 만들까? 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 위해서이다.

## 픽스처(Fixture)
테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처라고 한다. 일반적으로 여러 테스트에서 반복적으로 사용되기 때문에 @before 메소드를 이용해 생성해두면 편리하다.

## 확장클래스와 인터페이스, 어떤걸로 주입해야할까?
용도에 따라 결정된다. 인터페이스에 정의된 메소드를 테스트에서 사용하고 싶다면 인터페이스로, 확장된 클래스 자체에 관심이 있다면, 예를 들어 데이터베이스 연결 정보를 확인하고 싶다거나 한다면 확장클래스를 타입으로 지정한다.
Q. 191쪽 DI를 통해 외부에서 사용할 오브젝트를 주입받기 때문에 오브젝트 생성에 대한 부담을 지지 않아도 된다? 무슨의미지?

주입 시 인터페이스를 활용해야 하는 이유?
1. 개발에서 절대 바뀌지 않는 것은 없다. 인터페이스로 주입받게 하는 것이 추후 확장 클래스 여부를 걱정하지 않아도 되는 방법이다.
2. 다른 차원의 서비스 기능을 도입할 수 있다. 부가 기능을 추가하게 될 때 별도의 코드 수정을 줄일 수 있다.
3. 작은 단위의 테스트 작성에 용이하게 해준다.

> 여기까지는 di의 필요성이고, 용도에 따라 다르다던 앞의 말과 조금 다른거같은데..

## 테스트코드에 의한 DI
테스트에 필요한 데이터베이스 연결 정보를 테스트할 때마다 바꿔주는 것은 번거롭다. 이를 해결하기 위해선? 
1. 테스트 중에 사용할 오브젝트를 바꿔주면 된다. : 복잡한 의존관계를 가질 때 사용한다.

> @DirtiesContext // 테스트메소드에서 설정이나 상태를 변경한다는 것은 프레임워크에 알려준다.
// 이 어노테이션이 붙으면 애플리케이션 컨텍스트를 공유하지 않고 매번 새로운 컨텍스트를 만들도록 한다.
public class UserDaoTest {
	@Autowired
	UserDao dao;

	@Before
	public void setUp() {
		DataSource dataSource = new SingleConntectionDataSource(~~);
		dao.setDataSource(dataSource);	//코드에 의한 수동 DI
	}
}

원래는 테스트 내에서 상태를 변경하지 않는 것이 원칙이다. 그렇다면?

2. 테스트 전용 설정 파일을 따로 만든다!
@ContextConfiguration(locations=“locations=“/test-applicationContext”)

3. 아예 스프링 컨테이너를 사용하지 않는다. : 우선적으로 고려하자.
> public class UserDaoTest {

	UserDao dao;

	@Before
	public void setUp() {
		dao = new UserDao();
		DataSource dataSource = new SingleConntectionDataSource(~);
		dao.setDataSource(dataSource);
	}
}

# 학습 테스트
## 장점
1. 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
2. 학습 테스트 코드를 개발 중에 참고할 수 있다.
3. 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
4. 테스트 작성에 좋은 훈련이 된다.
5. 새로운 기술을 공부하는 과정이 즐거워진다.

## 예제
1. assertThat(A, is(not(B)));
	A. is : equals
	B. not : 뒤의 결과를 부정
2. assertThat(A, is(not(sameInstance(B)));
	A. sameInstance : 오브젝트 동일성 확인
3. assertThat(A, not(hasItem());
	A. hasItem : 컬렉션의 원소인지 확인
4. Set<JUnitTest> testObjects; testObjects.add(this);
	A. JUnitTest 결과를 add

# 버그테스트
## 장점
1. 테스트의 완성도를 높여준다.
2. 버그의 내용을 분석해준다.
3. 기술적인 문제를 해결하는데 도움이 된다.









